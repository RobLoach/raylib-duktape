const r = require('@raylib/api').raylib
const fs = require('fs')
const path = require('path')

const header = `
/**
 * This file is automatically generated by npm it.
 */
#include <duktape.h>
#include <dukglue/dukglue.h>
#include <dukglue/detail_primitive_types.h>
#include <raylib.h>
#include "raylib-duktape.h"
`

const functionHeader = `
void raylib_duktape_gen(duk_context* ctx) {
`

const footer = `
}
`

const definesBlacklist = [
    'RAYLIB_H',
    '__declspec(x)',
    'RLAPI',
    'DEG2RAD',
    'RAD2DEG',
    'RL_BOOL_TYPE',
    'RL_MALLOC(sz)',
    'RL_CALLOC(n,sz)',
    'RL_REALLOC(ptr,sz)',
    'RL_FREE(ptr)',
    'CLITERAL(type)',
    'RL_COLOR_TYPE',
    'RL_RECTANGLE_TYPE',
    'RL_VECTOR2_TYPE',
    'RL_VECTOR3_TYPE',
    'RL_VECTOR4_TYPE',
    'RL_QUATERNION_TYPE',
    'RL_MATRIX_TYPE',
    'RAYLIB_VERSION',
    'MOUSE_LEFT_BUTTON',
    'MOUSE_RIGHT_BUTTON',
    'MOUSE_MIDDLE_BUTTON',
    'MATERIAL_MAP_DIFFUSE',
    'MATERIAL_MAP_SPECULAR',
    'SHADER_LOC_MAP_DIFFUSE',
    'SHADER_LOC_MAP_SPECULAR',
]

r.enums.push({
    name: 'Custom',
    description: 'Additional defines',
    values: [
        { name: 'MOUSE_LEFT_BUTTON' },
        { name: 'MOUSE_RIGHT_BUTTON' },
        { name: 'MOUSE_MIDDLE_BUTTON' },
    ]
})

const defines = r.defines.map((define) => {
    if (definesBlacklist.includes(define.name)) {
        return `    // Skipped: ${define.name}`
    }
    return `    dukglue_register_global(ctx, ${define.name}, "${define.name}");`;
}).join('\n') + '\n'

const enums = r.enums.map((enumeration) => {
    const header = `    // ${enumeration.name}`
    const out = enumeration.values.map((val) => {
        return `    dukglue_register_global(ctx, (int)${val.name}, "${val.name}");`
    }).join('\n')

    return `${header}\n${out}\n`
}).join('\n') + '\n'


const functionBlacklist = [
    'TraceLog',
    'TextFormat',
    'SetShaderValue',
    'GetShaderLocationAttrib',
    'SetShaderValueV',
    'SetShaderValueMatrix',
    'SetShaderValueTexture',
    'UnloadShader',
    'MemAlloc',
    'MemRealloc',
    'MemFree',
    'LoadFileData',
    'UnloadFileData',
    'SaveFileData',
    'LoadFileText',
    'UnloadFileText',
    'SaveFileText',
    'CompressData',
    'DecompressData',
    'EncodeDataBase64',
    'DecodeDataBase64',
    'UpdateCamera',
    'DrawLineStrip',
    'DrawPolyLines',
    'DrawPolyLinesEx',
    'DrawTriangleFan',
    'DrawPolyLines',
    'DrawPolyLinesEx',
    'DrawTriangleStrip',
    'DrawPoly',
    'CheckCollisionLines',
    'LoadImageAnim',
    'LoadImageFromMemory',
    'ImageFormat',
    'ImageToPOT',
    'ImageCrop',
    'ImageAlphaCrop',
    'ImageAlphaClear',
    'ImageAlphaMask',
    'ImageAlphaPremultiply',
    'ImageResize',
    'ImageResizeNN',
    'ImageResizeCanvas',
    'ImageMipmaps',
    'ImageDither',
    'ImageFlipVertical',
    'ImageFlipHorizontal',
    'ImageRotateCW',
    'ImageRotateCCW',
    'ImageColorTint',
    'ImageColorInvert',
    'ImageColorGrayscale',
    'ImageColorContrast',
    'ImageColorBrightness',
    'ImageColorReplace',
    'LoadImageColors',
    'LoadImagePalette',
    'UnloadImageColors',
    'UnloadImagePalette',
    'GetImageAlphaBorder',
    'GetImageColor',
    'ImageClearBackground',
    'ImageDrawPixel',
    'ImageDrawPixelV',
    'ImageDrawLine',
    'ImageDrawLineV',
    'ImageDrawCircle',
    'ImageDrawCircleV',
    'ImageDrawRectangle',
    'ImageDrawRectangleV',
    'ImageDrawRectangleRec',
    'ImageDrawRectangleLines',
    'ImageDraw',
    'ImageDrawText',
    'ImageDrawTextEx',
    'UpdateTexture',
    'UpdateTextureRec',
    'GenTextureMipmaps',
    'GetPixelColor',
    'SetPixelColor',
    'GetPixelDataSize',
    'LoadFontEx',
    'LoadFontFromMemory',
    'LoadFontData',
    'GenImageFontAtlas',
    'UnloadFontData',
    'ExportFontAsCode',
    'DrawTexturePoly',
    'DrawTextCodepoints',
    'LoadCodepoints',
    'UnloadCodepoints',
    'GetCodepoint',
    'CodepointToUTF8',
    'TextCodepointsToUTF8',
    'TextCopy',
    'TextReplace',
    'TextJoin',
    'TextSplit',
    'TextAppend',
    'DrawTriangleStrip3D',
    'UploadMesh',
    'UpdateMeshBuffer',
    'DrawMeshInstanced',
    'GenMeshTangents',
    'LoadMaterials',
    'SetMaterialTexture',
    'SetModelMeshMaterial',
    'LoadModelAnimations',
    'UnloadModelAnimations',
    'LoadWaveFromMemory',
    'UpdateSound',
    'WaveCrop',
    'WaveFormat',
    'LoadWaveSamples',
    'UnloadWaveSamples',
    'LoadMusicStreamFromMemory',
    'UpdateAudioStream',
    'GetWindowHandle',
    'TextInsert',
    'SetTraceLogCallback',
    'SetLoadFileDataCallback',
    'SetSaveFileDataCallback',
    'SetLoadFileTextCallback',
    'SetSaveFileTextCallback',
    'SetAudioStreamCallback',
    'DetachAudioStreamProcessor',
    'AttachAudioStreamProcessor'
]
const functions = r.functions.map((func) => {
    let prefix = '    '
    if (functionBlacklist.includes(func.name)) {
        prefix = '    // '
    }
    return `${prefix}dukglue_register_function(ctx, &${func.name}, "${func.name}");`
}).join('\n')

function readPropertyTypeToFunction(type) {
    switch (type) {
        case 'unsigned int':
        case 'unsigned char':
            return ['duk_get_uint', 'duk_push_uint']
        case 'int':
            return ['duk_get_int', 'duk_push_int']
        case 'float':
        case 'double':
            return ['duk_get_number', 'duk_push_number']
        case 'const char*':
        case 'char[32]':
            return ['duk_get_string', 'duk_push_string']
        case 'char **':
            return ['(char**)duk_get_pointer', 'duk_push_pointer']
        case 'Transform **':
            return ['(Transform**)duk_get_pointer', 'duk_push_pointer']
        case 'float[2]':
        case 'float[4]':
        case 'Matrix[2]':
            return ['skip', 'skip']
        case 'bool':
            return ['duk_get_boolean', 'duk_push_boolean']
    }

    if (type.includes(' *')) {
        return [`(${type})duk_get_pointer`, 'duk_push_pointer']
    }
    return ['raylib_duktape_get<' + type + '>', 'raylib_duktape_push<' + type + '>']
}


const structHeader = `
namespace dukglue {
namespace types {
`

const structFooter = '}}'
const structs = structHeader + r.structs.map((structure) => {

    let readProperties = ''
    let pushProperties = ''
    for (let field of structure.fields) {
        const func = readPropertyTypeToFunction(field.type)
        if (func[0] != 'skip') {
        readProperties += `
        duk_get_prop_string(ctx, arg_idx, "${field.name}");
        out.${field.name} = ${func[0]}(ctx, -1);`
        }
        else {
            readProperties += `\n        // Skipped: ${field.name}`
        }
        if (func[1] != 'skip') {
        pushProperties += `
        ${func[1]}(ctx, value.${field.name});
        duk_put_prop_string(ctx, obj_idx, "${field.name}");`
        }
        else {
            pushProperties += `\n        // Skipped: ${field.name}`
        }
    }
    return `template<>
struct DukType<::${structure.name}> {
    typedef std::true_type IsValueType;
    template<typename FullT>
    static ::${structure.name} read(duk_context* ctx, duk_idx_t arg_idx) {
        if (!duk_is_object(ctx, arg_idx)) {
            duk_int_t type_idx = duk_get_type(ctx, arg_idx);
            duk_error(ctx, DUK_ERR_TYPE_ERROR, "Argument %d: expected object, got %s", arg_idx, detail::get_type_name(type_idx));
        }
        ::${structure.name} out;${readProperties}
        return out;
    }
    template<typename FullT>
    static void push(duk_context* ctx, ::${structure.name} value) {
        duk_idx_t obj_idx = duk_push_object(ctx);
        ${pushProperties}
    }
};\n`
}).join('\n') + structFooter

fs.writeFileSync(path.join(__dirname, '..', 'lib', 'raylib-duktape-gen.h'),
    header +
    structs +
    functionHeader +
    enums +
    defines +
    functions +
    footer);
